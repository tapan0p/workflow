module.exports = function(RED) {
    var mqtt = require('mqtt');
    const fs = require('fs');
    const path = require('path');
    
    function Triplets(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.outputHistory = [];
        this.payload = config.payload;
        this.topic = config.topic;
        this.qos = parseInt(config.qos || 0);
        this.debugLog = config.debugLog;
        
        // Store the node path for debug messages
        this._path = RED.nodes.getNode(config.z) ? 
                    RED.nodes.getNode(config.z).path + ":" + config.id : 
                    config.id;
        
        this.prompt = config.prompt;
        this.objective = config.objective;
        
        this.templates = config.templates || [];
        
        this.apiEndpoint = config.apiEndpoint;
        
        this.functions = config.functions || [];
        this.functionObjects = [];
        
        // Store function definitions but don't try to execute Python code
        // Just store them as documentation/reference for tools
        if (this.functions.length > 0) {
            this.functions.forEach(function(functionDef) {
                node.functionObjects.push({
                    name: functionDef.name,
                    code: functionDef.code // Just store the code as is
                });
            });
        }
        
        this.status({fill:'yellow', shape:'ring', text:'connecting to mqtt...'});
        
        
        this.broker = RED.nodes.getNode(config.broker);

        if (this.broker) {
            try {
                // Instead of using broker.connect(), create our own MQTT client:
                var options = {
                    clientId: 'triplet_' + Math.random().toString(16).substring(2, 8),
                    clean: true
                };
                
                // Get connection details from broker config
                var brokerUrl = 'mqtt://' + this.broker.broker + ':' + this.broker.port;
                
                // Create MQTT client directly
                this.client = mqtt.connect(brokerUrl, options);
                
                if (this.client) {
                    this.client.on('connect', function() {
                        node.status({fill:"green", shape:"dot", text:"mqtt connected"});
                        
                        if (node.topic) {
                            node.client.subscribe(node.topic, {qos: node.qos});
                        } else {
                            node.warn("MQTT topic not specified");
                        }
                    });

                    this.client.on('message', function(topic, message) {
                        try {
                            // Create a new message object from the MQTT message
                var msg = {
                                topic: topic,
                                payload: message.toString()
                            };
                            
                            // Try to parse payload as JSON
                            try {
                                msg.payload = JSON.parse(msg.payload);
                            } catch (parseError) {
                                // If not valid JSON, keep as string
                                node.warn("MQTT message is not valid JSON, using as string");
                            }
                            
                            // Mark message as processed by triplets
                            msg.processed_by_triplets = true;
                            
                            // Process with tools first
                            msg = processWithFunctions(msg);
                            
                            // Generate triplets
                            var generatedTriplets = [];
                            var storeTriplets = [];
                            
                            node.templates.forEach(function(template) {
                                if (template.subject && template.predicate && template.object) {
                                    // Generate triplet
                                    var triplet = {
                                        subject: template.subject,
                                        predicate: template.predicate,
                                        object: template.object
                                    };
                                    
                                    // Apply dynamic values if needed
                                    if (typeof msg.payload === 'object') {
                                        for (var key in triplet) {
                                            if (triplet[key].startsWith('msg.')) {
                                                var path = triplet[key].substring(4).split('.');
                                                var value = msg;
                                                
                                                // Navigate the path
                                                for (var i = 0; i < path.length; i++) {
                                                    if (value === undefined || value === null) break;
                                                    value = value[path[i]];
                                                }
                                                
                                                // Set the triplet value if path resolved
                                                if (value !== undefined && value !== null) {
                                                    triplet[key] = value.toString();
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Add to generated triplets
                                    generatedTriplets.push(triplet);
                                    
                                    // Add to store triplets if template has storage enabled
                                    if (template.enableStorage && node.apiEndpoint) {
                                        storeTriplets.push(triplet);
                                    }
                                }
                            });
                            
                            // Add triplets to message
                            if (generatedTriplets.length > 0) {
                                if (!msg.triplets) {
                                    msg.triplets = [];
                                }
                                
                                msg.triplets = msg.triplets.concat(generatedTriplets);
                                
                                // Update the prompt with triplet templates if it exists
                                if (node.prompt) {
                                    msg.prompt = node.prompt;
                                    
                                    // Append each triplet definition to the prompt
                                    generatedTriplets.forEach(function(triplet) {
                                        msg.prompt += "\nTriplet: " + triplet.subject + " - " + triplet.predicate + " - " + triplet.object;
                                    });
                                }
                                
                                // Try to store triplets if any are marked for storage
                                if (storeTriplets.length > 0 && node.apiEndpoint) {
                                    try {
                                        // Prepare storage request with timestamp
                                        var storageRequest = {
                                            triplets: storeTriplets,
                                            timestamp: new Date().toISOString()
                                        };
                                        
                                        // Send storage request
                                        // This would typically be an HTTP request, but we're just logging for now
                                        node.warn("Would store " + storeTriplets.length + " triplets to: " + node.apiEndpoint);
                                        node.status({fill:"blue", shape:"dot", text:"mqtt: storing " + storeTriplets.length});
                                    } catch (storeError) {
                                        node.error("Error storing triplets: " + storeError.toString());
                                    }
                                }
                            }
                            
                            // Include prompt and objective if set (only if not already set by triplets)
                            if (node.prompt && !msg.prompt) {
                                msg.prompt = node.prompt;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.prompt = node.prompt;
                                }
                            }
                            
                            if (node.objective) {
                                msg.objective = node.objective;
                                // Also add to payload for easier access
                                if (typeof msg.payload === 'object') {
                                    msg.payload.objective = node.objective;
                                }
                            }
                            
                            // Send the constructed message using the helper
                            sendAndUpdatePreview(msg);
                            
                        } catch (err) {
                            node.error("Error processing MQTT message: " + err.toString());
                        }
                    });

                    this.client.on('close', function() {
                        node.status({fill:'red', shape:'ring', text:'mqtt disconnected'});
                    });

                    this.client.on('error', function(err) {
                        node.status({fill:'red', shape:'ring', text:'mqtt error'});
                        node.error("MQTT error: " + err.toString());
                    });

                    this.on('close', function(done) {
                        if (node.client) {
                            if (node.topic) {
                                node.client.unsubscribe(node.topic);
                            }
                            node.client.end(true, done);
                        } else {
                            done();
                        }
                    });
                } else {
                    node.error("Failed to create MQTT client");
                    this.status({fill:'red', shape:'ring', text:'mqtt client creation failed'});
                }
            } catch (err) {
                node.error("Error creating MQTT client: " + err.toString());
                this.status({fill:'red', shape:'ring', text:'mqtt setup error'});
            }
        } else {
            node.error("MQTT broker not configured");
            this.status({fill:'red', shape:'ring', text:'mqtt broker not configured'});
        }

        // Function to process message with tools
        function processWithFunctions(msg) {
            // Since the functions are Python code examples and not intended to be executed,
            // we just log the available tools and return the message unchanged
            if (node.functionObjects && node.functionObjects.length > 0) {
                // If this is the first message processed, log the available tools
                if (!node._toolsLogged) {
                    node.log(`Node has ${node.functionObjects.length} tool definitions available (documentation only)`);
                    node.functionObjects.forEach(function(funcObj, index) {
                        node.log(`Tool ${index+1}: ${funcObj.name}`);
                    });
                    node._toolsLogged = true;
                }
                
                // Add the tool definitions to the message for reference
                if (!msg.tools) {
                    msg.tools = [];
                }
                
                // Just add the tool names to the message
                node.functionObjects.forEach(function(funcObj) {
                    if (!msg.tools.includes(funcObj.name)) {
                        msg.tools.push(funcObj.name);
                    }
                });
            }
            return msg;
        }

        // Helper function to send message and update history/comms
        function sendAndUpdatePreview(msg) {
            if(!msg){
                return;
            }
            // print the message in the node-red debug tab
            node.log(msg.payload);
            var debugMsg = RED.util.cloneMessage(msg.payload);
            var newMessage = {
                id:node.id,
                msg:debugMsg,
            }
            RED.comms.publish("debug", {
                msg: newMessage
            });

            // I want to save the messages in the history.json file
            const historyDir = path.join(RED.settings.userDir, 'public', 'data');
            const historyFile = path.join(historyDir, 'history.json');
            
            // Create the directory if it doesn't exist
            fs.mkdirSync(historyDir, { recursive: true });

            // store the message in the history.json file based on the node id
            // the json file should be like this:
            /* 
            {
                id:[message1,message2,message3]
            }
                the letest message should be the first one
                the oldest message should be the last one
            */
           // initialise the history array if it doesn't exist
            var history = JSON.parse(fs.readFileSync(historyFile, 'utf8'));
            if(!history[node.id]){
                history[node.id] = [];
            }
            history[node.id].unshift(debugMsg);
            fs.writeFileSync(historyFile, JSON.stringify(history, null, 2));

            // I want to send the history of this to frontend of this triplet node
            var currentNodeHistory = history[node.id];
            RED.comms.publish("triplets_history/" + node.id, {
                id: node.id,
                msg: currentNodeHistory
            });
        }

        // Handle normal input flow messages
        this.on("input", function(msg, send, done) {
            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
            }
            
            // Mark message as processed
            msg.processed_by_triplets = true;
            
            // Process with tools
            try {
                msg = processWithFunctions(msg);
            } catch (err) {
                node.error("Error running tools: " + err.toString(), msg);
            }
            
            // Create a text representation of triplet templates to add to the prompt
            var templatesText = "Knowledge Triplet Templates:\n";
            
            node.templates.forEach(function(template) {
                templatesText += `${template.subject} ${template.predicate} [${template.object}]\n`;
            });
            
            // Store the templates text for use in the prompt
            msg.templatesText = templatesText;
            
            // Store the original prompt if set
            var originalPrompt = node.prompt || '';
            
            // If prompt is already set, append the templates
            if (originalPrompt) {
                msg.prompt = originalPrompt + "\n\n" + templatesText;
            } else {
                msg.prompt = templatesText;
            }
            
            // Also add to payload for easier access
            if (typeof msg.payload === 'object') {
                msg.payload.templatesText = templatesText;
                msg.payload.prompt = msg.prompt;
            }
            
            var triplets = [];
            var storeTriplets = []; // Separate array for triplets to be stored
            var data = {};
            
            // Extract data from payload
            if (typeof msg.payload === 'object') {
                data = msg.payload;
            } else if (typeof msg.payload === 'string') {
                try {
                    data = JSON.parse(msg.payload);
                } catch(e) {
                    data = { value: msg.payload };
                }
            } else {
                data = { value: msg.payload };
            }
            
            // Process each template to extract triplets
            node.templates.forEach(function(template) {
                // Extract path from object field if it exists
                if (template.subject && template.predicate && template.object) {
                    var objectPath = template.object;
                    var value;
                    
                    // Handle dynamic paths (msg.payload.something)
                    if (objectPath.startsWith('msg.')) {
                        var path = objectPath.substring(4).split('.');
                        value = msg;
                        
                        // Navigate the path
                        for (var i = 0; i < path.length; i++) {
                            if (value === undefined || value === null) break;
                            value = value[path[i]];
                        }
                    } else {
                        // Try direct access from data
                        value = data[objectPath];
                    }
                    
                    // Create the triplet if value was found
                    if (value !== undefined && value !== null) {
                        // Convert to string if needed
                        if (typeof value !== 'string') {
                            value = value.toString();
                        }
                        
                        var triplet = {
                            subject: template.subject,
                            predicate: template.predicate,
                            object: value
                        };
                        
                        // Add to all triplets array
                        triplets.push(triplet);
                        
                        // If this template has storage enabled, add to the store array
                        if (template.enableStorage && node.apiEndpoint) {
                            storeTriplets.push(triplet);
                        }
                    }
                }
            });
            
            // Add triplets to message for storage and other uses
            msg.triplets = triplets;
            
            // Store triplets that are marked for storage
            if (storeTriplets.length > 0 && node.apiEndpoint) {
                try {
                    // Create storage request
                    var storageMsg = {
                        url: node.apiEndpoint,
                        method: "POST",
                        payload: {
                            triplets: storeTriplets,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                    // Log the storage attempt
                    node.status({fill:"green", shape:"dot", text:"storing triplets: " + storeTriplets.length});
                    
                    // Include storage message
                    msg.storageRequest = storageMsg;
                } catch(err) {
                    node.error("Error preparing storage: " + err.toString(), msg);
                    node.status({fill:"red", shape:"ring", text:"storage error"});
                }
            }
            
            // Include prompt and objective if set (only if not already set by triplets)
            if (node.prompt && !msg.prompt) {
                msg.prompt = node.prompt;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.prompt = node.prompt;
                }
            }
            
            if (node.objective) {
                msg.objective = node.objective;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.objective = node.objective;
                }
            }
            
            // Handle MQTT topic changes - always enabled
            if (node.client && msg.mqtt_control) {
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        if (node.topic) {
                    node.client.unsubscribe(node.topic);
                        }
                        node.topic = msg.topic;
                        node.client.subscribe(node.topic, {qos: node.qos});
                        node.status({fill:"green", shape:"dot", text:"mqtt: " + node.topic});
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                            node.topic = '';
                            node.status({fill:"yellow", shape:"dot", text:"mqtt: no subscription"});
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                    }
                }
            }
            
            // Send the message using the helper function
            sendAndUpdatePreview(msg); // Send handled by helper

            if (done) {
                done();
            }
        });

        
    }
    RED.nodes.registerType("triplets", Triplets);
}