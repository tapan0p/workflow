module.exports = function(RED) {
    var mqtt = require('mqtt');
    const fs = require('fs');
    const path = require('path');
    
    function UnitNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.outputHistory = [];
        this.payload = config.payload;
        this.topic = config.topic;
        this.debugLog = config.debugLog;
        
        // Store the node path for debug messages
        this._path = RED.nodes.getNode(config.z) ? 
                    RED.nodes.getNode(config.z).path + ":" + config.id : 
                    config.id;
        
        this.prompt = config.prompt;
        this.objective = config.objective;
        
        this.templates = config.templates || [];
        
        this.functions = config.functions || [];
        this.functionObjects = [];

        this.hasBeenSaved = config.hasBeenSaved || false;

        // --- Status Handling ---
        let processingTimeout = null;
        function setNodeProcessingStatus(isProcessing) {
            clearTimeout(processingTimeout);
            if (isProcessing) {
                node.status({ fill: "green", shape: "ring", text: "processing" });
            } else {
                processingTimeout = setTimeout(() => {
                    node.status({ fill: "red", shape: "ring", text: "idle" });
                }, 500);
            }
        }
        // Set initial status
        node.status({ fill: "red", shape: "ring", text: "idle" });
        // --- End Status Handling ---

        // Function to process message with functions (adds them as properties without execution)
        function processWithFunctions(msg) {
            try {
                if (node.functions && node.functions.length > 0) {
                    // Add functions as a property to the message
                    if (!msg.available_functions) {
                        msg.available_functions = [];
                    }
                    
                    node.functions.forEach(function(funcDef) {
                        if (funcDef.name && funcDef.code) {
                            // Add function definition to message without executing
                            msg.available_functions.push({
                                name: funcDef.name,
                                code: funcDef.code,
                                description: funcDef.description || ""
                            });
                        }
                    });
                }
                return msg;
            } catch (err) {
                node.error("Error in processWithFunctions: " + err.toString());
                return msg;
            }
        }

        // Function to connect to MQTT using global config file
        const connectToMqtt = async () => {
            const configPath = path.join(RED.settings.userDir, 'mqttConfig.json');
            let mqttConfig;

            try {
                if (fs.existsSync(configPath)) {
                    mqttConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                } else {
                    node.warn(`MQTT config file not found: ${configPath}. Using defaults.`);
                    mqttConfig = { broker: "localhost", port: "1883", qos: "0" };
                }
            } catch (err) {
                node.error(`Error reading MQTT config file ${configPath}: ${err.toString()}. Using defaults.`);
                mqttConfig = { broker: "localhost", port: "1883", qos: "0" }; // Fallback defaults
            }

            console.log("Retrieved MQTT Config from file:", mqttConfig);

            try {
                if (this.client) {
                    console.log(`Node ${node.id}: Closing existing MQTT connection`);
                    await new Promise((resolve, reject) => {
                        this.client.end(true, {}, (err) => { // Added error handler for end
                             if (err) {
                                 console.error(`Node ${node.id}: Error closing previous MQTT connection: ${err.toString()}`);
                                 // Don't necessarily reject, maybe just log and continue
                             }
                             console.log(`Node ${node.id}: Existing MQTT connection closed`);
                             resolve();
                        });
                    });
                    this.client = null; 
                }

                // Create MQTT client options
                var options = {
                    clientId: 'unit_node_' + Math.random().toString(16).substring(2, 8) + node.id,
                    clean: true,
                    reconnectPeriod: 5000
                };

                // Get connection details from the file config
                var brokerUrl = 'mqtt://' + mqttConfig.broker + ':' + mqttConfig.port;
                const qosLevel = parseInt(mqttConfig.qos || "0");
                console.log(`Node ${node.id}: Connecting to MQTT broker: ${brokerUrl} with QoS ${qosLevel}`);

                // Create MQTT client
                this.client = mqtt.connect(brokerUrl, options);

                if (this.client) {
                    // Set up event listeners immediately after creating the client
                    this.client.on('connect', () => {
                        console.log(`Node ${node.id}: Connected to MQTT broker ${brokerUrl}`);
                        node.status({ fill: "blue", shape: "dot", text: "mqtt" });

                        if (node.topic) {
                            node.client.subscribe(node.topic, { qos: qosLevel }, (err, granted) => {
                                if (err) {
                                    node.error(`Failed to subscribe to topic ${node.topic}: ${err.toString()}`);
                                    node.status({ fill: "red", shape: "ring", text: `subscribe failed: ${err.message}` });
                                } else {
                                    console.log(`Node ${node.id}: Successfully subscribed to topic ${node.topic} with QoS ${granted[0]?.qos}`);
                                    node.status({ fill: "green", shape: "dot", text: `subscribed` });
                                }
                            });
                        } else {
                            node.warn(`Node ${node.id}: MQTT topic not specified in node configuration.`);
                            node.status({ fill: "yellow", shape: "ring", text: "no topic set" });
                        }
                    });

                    this.client.on('message', (topic, message) => { // Arrow function for correct `this`
                        try {
                            setNodeProcessingStatus(true);
                            var msg = {
                                topic: topic,
                                payload: message.toString()
                            };

                            try {
                                msg.payload = JSON.parse(msg.payload);
                            } catch (parseError) {
                                
                            }

                            // Add debug message to global debug log
                            RED.comms.publish("debug", {
                                id: node.id,
                                z: node.z,
                                _alias: node._alias,
                                path: node._flow.path,
                                name: node.name || "unit-node",
                                topic: topic,
                                msg: {
                                    topic: topic,
                                    payload: msg.payload
                                }
                            });

                            msg.processed_by_unit_node = true;

                            // Process with functions if defined
                            msg = processWithFunctions(msg);

                            var generatedTriplets = [];
                            var storeTriplets = [];

                            node.templates.forEach(function(template) {
                                if (template.subject && template.predicate && template.object) {
                                    var triplet = {
                                        subject: template.subject,
                                        predicate: template.predicate,
                                        object: template.object
                                    };

                                    if (typeof msg.payload === 'object' && msg.payload !== null) { // Check for null payload
                                        for (var key in triplet) {
                                            if (triplet[key].startsWith('msg.')) {
                                                var path = triplet[key].substring(4).split('.');
                                                var value = msg;

                                                try { // Add try-catch for path navigation
                                                    for (var i = 0; i < path.length; i++) {
                                                        if (value === undefined || value === null) break;
                                                        value = value[path[i]];
                                                    }
                                                } catch (pathError) {
                                                    node.warn(`Error accessing path ${triplet[key]}: ${pathError.toString()}`);
                                                    value = undefined; // Ensure value is undefined if path fails
                                                }

                                                if (value !== undefined && value !== null) {
                                                    triplet[key] = value.toString();
                                                } else {
                                                    // If value not found, maybe don't add the triplet or log warning?
                                                    // For now, let's keep the original path string if value is null/undefined
                                                    // triplet[key] = template[key]; // Or remove the triplet?
                                                }
                                            }
                                        }
                                    }

                                    generatedTriplets.push(triplet);

                                    if (template.enableStorage) {
                                        storeTriplets.push(triplet);
                                    }
                                }
                            });

                            if (generatedTriplets.length > 0) {
                                if (!msg["unit-node"]) {
                                    msg["unit-node"] = [];
                                }

                                msg["unit-node"] = msg["unit-node"].concat(generatedTriplets);

                                if (node.prompt) {
                                    // Ensure prompt exists before appending
                                    if (!msg.prompt) { msg.prompt = ""; }
                                    msg.prompt += node.prompt; // Append node prompt first

                                    generatedTriplets.forEach(function(triplet) {
                                        msg.prompt += "\nTriplet: " + triplet.subject + " - " + triplet.predicate + " - " + triplet.object;
                                    });
                                }

                                if (storeTriplets.length > 0) {
                                    try {
                                        var storageRequest = {
                                            "unit-node": storeTriplets,
                                            timestamp: new Date().toISOString()
                                        };

                                        node.warn("Would store " + storeTriplets.length + " triplets");
                                        // Actual storage logic would go here if implemented
                                    } catch (storeError) {
                                        node.error("Error preparing triplets for storage: " + storeError.toString());
                                    }
                                }
                            }

                            // Ensure prompt/objective added correctly
                            if (node.prompt && !msg.prompt) { // Check if prompt wasn't added via triplets
                                msg.prompt = node.prompt;
                            }
                            if (typeof msg.payload === 'object' && msg.payload !== null && node.prompt) {
                                msg.payload.prompt = msg.prompt; // Ensure payload reflects final prompt
                            }

                            if (node.objective) {
                                msg.objective = node.objective;
                                if (typeof msg.payload === 'object' && msg.payload !== null) {
                                    msg.payload.objective = node.objective;
                                }
                            }

                            // --- Send and Reset Status ---
                            try {
                                node.send(msg);
                                setNodeProcessingStatus(false);
                            } catch (sendErr) {
                                node.error("Error sending MQTT processed message: " + sendErr.toString(), msg);
                                setNodeProcessingStatus(false);
                            }
                            // --- End Send and Reset Status ---

                        } catch (err) {
                            node.error(`Node ${node.id}: Error processing MQTT message on topic ${topic}: ${err.toString()}`, msg);
                            setNodeProcessingStatus(false);
                        }
                    });

                    this.client.on('error', (err) => {
                        console.error(`Node ${node.id}: MQTT client error:`, err);
                        node.error("MQTT client error: " + err.toString());
                        node.status({ fill: 'red', shape: 'ring', text: 'client error' });
                    });

                    this.client.on('close', () => {
                        console.log(`Node ${node.id}: MQTT connection closed.`);
                        node.status({ fill: 'red', shape: 'ring', text: 'disconnected' });
                    });

                    this.client.on('reconnect', () => {
                        console.log(`Node ${node.id}: Attempting to reconnect to MQTT broker...`);
                        node.status({ fill: 'yellow', shape: 'ring', text: 'reconnecting' });
                    });

                    this.client.on('offline', () => {
                         console.log(`Node ${node.id}: MQTT client offline.`);
                         node.status({ fill: 'red', shape: 'dot', text: 'offline' });
                     });

                } else {
                    node.error(`Node ${node.id}: Failed to create MQTT client`);
                    node.status({ fill: 'red', shape: 'ring', text: 'client creation failed' });
                }
            } catch (err) {
                console.error(`Node ${node.id}: Error in connectToMqtt function:`, err);
                node.error("Error setting up MQTT connection: " + err.toString());
                node.status({ fill: 'red', shape: 'ring', text: 'mqtt setup error' });
            }
        };

        // Add listener for file update event
        this.mqttConfigFileUpdateListener = () => {
            connectToMqtt().catch(err => {
                 node.error(`Node ${node.id}: Error reconnecting after config file update: ${err.toString()}`);
            });
        };
        RED.events.on("mqtt-config-file-updated", this.mqttConfigFileUpdateListener);

        // Initial connection - Keep a short delay
        setTimeout(() => {
            connectToMqtt().catch(err => {
                
            });
        }, 500); // Reduced delay

        // Store function definitions but don't try to execute Python code
        // Just store them as documentation/reference for tools
        if (this.functions.length > 0) {
            this.functions.forEach(function(functionDef) {
                node.functionObjects.push({
                    name: functionDef.name,
                    code: functionDef.code // Just store the code as is
                });

                // add functionDef to the doxigen_data.json file if the function does not already exist 
                // if the file does not exist, create it
                // define the path to the doxigen_data.json file
                const doxigenDataPath = path.join(RED.settings.userDir, 'public', 'data', 'custom_doxigen_data.json');
                // Ensure directory exists
                const dataDir = path.dirname(doxigenDataPath);
                if (!fs.existsSync(dataDir)) {
                    fs.mkdirSync(dataDir, { recursive: true });
                }

                let doxigenData = { tools: [] };
                if (fs.existsSync(doxigenDataPath)) {
                    try {
                        doxigenData = JSON.parse(fs.readFileSync(doxigenDataPath, 'utf8'));
                        if (!doxigenData.tools) doxigenData.tools = [];
                    } catch (e) {
                        node.warn(`Error reading custom_doxigen_data.json: ${e.toString()}. Starting with empty tools list.`);
                        doxigenData = { tools: [] };
                    }
                }

                const existingFunctionNames = doxigenData.tools.map(tool => tool.name);
                const newFunctions = config.functions.filter(func => func.name && !existingFunctionNames.includes(func.name)); // Ensure name exists

                if (newFunctions.length > 0) {
                     newFunctions.forEach(func => {
                         doxigenData.tools.push(func);
                     });
                     try {
                         fs.writeFileSync(doxigenDataPath, JSON.stringify(doxigenData, null, 2));
                         
                     } catch (writeErr) {
                         node.error(`Failed to write updated custom_doxigen_data.json: ${writeErr.toString()}`);
                     }
                }
            });
        }

        // Handle normal input flow messages
        this.on("input", function(msg, send, done) {
            setNodeProcessingStatus(true);

            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
            }
            
            // Mark message as processed
            msg.processed_by_unit_node = true;
            
            // Process with tools
            try {
                msg = processWithFunctions(msg);
            } catch (err) {
                node.error("Error running tools: " + err.toString(), msg);
            }
            
            // Create a text representation of triplet templates to add to the prompt
            var templatesText = "Knowledge Triplet Templates:\n";
            
            node.templates.forEach(function(template) {
                templatesText += `${template.subject} ${template.predicate} [${template.object}]\n`;
            });
            
            // Store the templates text for use in the prompt
            msg.templatesText = templatesText;
            
            // Store the original prompt if set
            var originalPrompt = node.prompt || '';
            
            // If prompt is already set, append the templates
            if (originalPrompt) {
                msg.prompt = originalPrompt + "\n\n" + templatesText;
            } else {
                msg.prompt = templatesText;
            }
            
            // Also add to payload for easier access
            if (typeof msg.payload === 'object' && msg.payload !== null) {
                msg.payload.templatesText = templatesText;
                msg.payload.prompt = msg.prompt;
            }
            
            var triplets = [];
            var storeTriplets = []; // Separate array for triplets to be stored
            var data = {};
            
            // Extract data from payload
            if (typeof msg.payload === 'object' && msg.payload !== null) {
                data = msg.payload;
            } else if (typeof msg.payload === 'string') {
                try {
                    data = JSON.parse(msg.payload);
                } catch(e) {
                    data = { value: msg.payload };
                }
            } else {
                data = { value: msg.payload };
            }
            
            // Process each template to extract triplets
            node.templates.forEach(function(template) {
                // Extract path from object field if it exists
                if (template.subject && template.predicate && template.object) {
                    var objectPath = template.object;
                    var value;
                    
                    // Handle dynamic paths (msg.payload.something)
                    if (objectPath.startsWith('msg.')) {
                        var path = objectPath.substring(4).split('.');
                        value = msg;
                        
                        // Navigate the path
                        try {
                             for (var i = 0; i < path.length; i++) {
                                 if (value === undefined || value === null) break;
                                 value = value[path[i]];
                             }
                        } catch (pathError) {
                            node.warn(`Error accessing path ${objectPath}: ${pathError.toString()}`);
                            value = undefined;
                        }
                    } else {
                        // Try direct access from data
                        // This logic seems unlikely to work well unless the object path is a direct key in payload
                         value = data[objectPath];
                    }
                    
                    // Create the triplet if value was found
                    if (value !== undefined && value !== null) {
                        // Convert to string if needed
                        if (typeof value !== 'string') {
                            value = value.toString();
                        }
                        
                        var triplet = {
                            subject: template.subject,
                            predicate: template.predicate,
                            object: value
                        };
                        
                        // Add to all triplets array
                        triplets.push(triplet);
                        
                        // If this template has storage enabled, add to the store array
                        if (template.enableStorage) {
                            storeTriplets.push(triplet);
                        }
                    }
                }
            });
            
            // Add triplets to message for storage and other uses
            msg["unit-node"] = triplets;
            
            // Store triplets that are marked for storage
            if (storeTriplets.length > 0) {
                try {
                    // Create storage request
                    var storageMsg = {
                        method: "POST",
                        payload: {
                            "unit-node": storeTriplets,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                    // Log the storage attempt
                    node.status({fill:"blue", shape:"dot", text:`storing ${storeTriplets.length} triplets`}); // Use different status
                    
                    // Include storage message
                    msg.storageRequest = storageMsg;
                } catch(err) {
                    node.error("Error preparing storage: " + err.toString(), msg);
                    node.status({fill:"red", shape:"ring", text:"storage prep error"});
                }
            }
            
            // Include prompt and objective if set
            if (node.prompt && !msg.prompt) {
                 msg.prompt = node.prompt;
                 if (typeof msg.payload === 'object' && msg.payload !== null) {
                     msg.payload.prompt = node.prompt;
                 }
             }
            
            if (node.objective) {
                msg.objective = node.objective;
                if (typeof msg.payload === 'object' && msg.payload !== null) {
                    msg.payload.objective = node.objective;
                }
            }
            
            // Handle MQTT topic changes - always enabled
            if (node.client && node.client.connected && msg.mqtt_control) { // Check if client connected
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        const currentTopic = node.topic; // Store current topic before changing
                        const newTopic = msg.topic;

                        // Unsubscribe from old topic if different
                        if (currentTopic && currentTopic !== newTopic) {
                             console.log(`Node ${node.id}: Unsubscribing from old topic ${currentTopic}`);
                            node.client.unsubscribe(currentTopic, (err) => {
                                 if (err) { node.error(`Error unsubscribing from ${currentTopic}: ${err.toString()}`); }
                            });
                        }

                        node.topic = newTopic; // Update node property

                        // Read QoS from file config
                        const configPath = path.join(RED.settings.userDir, 'mqttConfig.json');
                        let qosLevel = 0; // Default QoS
                        if (fs.existsSync(configPath)) {
                            try {
                                const mqttConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                                qosLevel = parseInt(mqttConfig.qos || "0");
                            } catch(e) { node.warn(`Could not read QoS from mqttConfig.json for dynamic subscribe to ${newTopic}`); }
                        }
                        console.log(`Node ${node.id}: Dynamically subscribing to topic ${newTopic} with QoS ${qosLevel}`);
                        node.client.subscribe(newTopic, { qos: qosLevel }, (err, granted) => {
                             if (err) {
                                 node.error(`Error subscribing to ${newTopic}: ${err.toString()}`);
                             } else {
                                 console.log(`Node ${node.id}: Successfully subscribed to ${newTopic} with QoS ${granted[0]?.qos}`);
                             }
                         });
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            const topicToUnsub = node.topic;
                             console.log(`Node ${node.id}: Unsubscribing from topic ${topicToUnsub}`);
                            node.client.unsubscribe(topicToUnsub, (err) => {
                                if (err) { node.error(`Error unsubscribing from ${topicToUnsub}: ${err.toString()}`); }
                                else { node.topic = ''; } // Clear topic only on success
                            });
                        } else {
                             node.warn(`Node ${node.id}: Received unsubscribe command but no topic was set.`);
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                    }
                }
            } else if (msg.mqtt_control) {
                 node.warn(`Node ${node.id}: Received MQTT control message but client is not connected.`);
            }
            
            // Send the message and trigger status reset
            try {
                 send(msg);
                 setNodeProcessingStatus(false);
            } catch (err) {
                node.error("Error sending message: " + err.toString(), msg);
                setNodeProcessingStatus(false);
            }

            if (done) {
                done();
            }
        });

        // Clean up subscription when node is removed
        this.on('close', function(done) {
            console.log(`Node ${node.id}: Closing node...`);
            // Remove the file update listener on close
            if (this.mqttConfigFileUpdateListener) {
                 RED.events.removeListener("mqtt-config-file-updated", this.mqttConfigFileUpdateListener);
                 console.log(`Node ${node.id}: Removed mqtt-config-file-updated listener.`);
            }
            // Removed listener removal
            if (this.client) {
                console.log(`Node ${node.id}: Ending MQTT client connection.`);
                // Add timeout for closing connection
                const closeTimeout = setTimeout(() => {
                    console.warn(`Node ${node.id}: MQTT client close timed out.`);
                    this.client.removeAllListeners(); // Force remove listeners
                    done();
                }, 2000); // 2 second timeout

                this.client.end(false, {}, (err) => { // Use end(false) for graceful disconnect
                    clearTimeout(closeTimeout);
                    if(err) {
                         console.error(`Node ${node.id}: Error closing MQTT client: ${err.toString()}`);
                    }
                    console.log(`Node ${node.id}: MQTT client closed successfully.`);
                    done();
                });
            } else {
                console.log(`Node ${node.id}: No MQTT client to close.`);
                done();
            }
        });
    }
    RED.nodes.registerType("unit-node", UnitNode);
}