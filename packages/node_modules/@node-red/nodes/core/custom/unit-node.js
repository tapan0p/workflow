module.exports = function(RED) {
    var mqtt = require('mqtt');
    const fs = require('fs');
    const path = require('path');
    
    function UnitNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;
        node.outputHistory = [];
        this.payload = config.payload;
        this.topic = config.topic;
        this.qos = parseInt(config.qos || 0);
        this.debugLog = config.debugLog;
        
        // Store the node path for debug messages
        this._path = RED.nodes.getNode(config.z) ? 
                    RED.nodes.getNode(config.z).path + ":" + config.id : 
                    config.id;
        
        this.prompt = config.prompt;
        this.objective = config.objective;
        
        this.templates = config.templates || [];
        
        this.apiEndpoint = config.apiEndpoint;

        this.functions = config.functions || [];
        this.functionObjects = [];

        this.hasBeenSaved = config.hasBeenSaved || false;

        // Function to process message with functions (adds them as properties without execution)
        function processWithFunctions(msg) {
            try {
                if (node.functions && node.functions.length > 0) {
                    // Add functions as a property to the message
                    if (!msg.available_functions) {
                        msg.available_functions = [];
                    }
                    
                    node.functions.forEach(function(funcDef) {
                        if (funcDef.name && funcDef.code) {
                            // Add function definition to message without executing
                            msg.available_functions.push({
                                name: funcDef.name,
                                code: funcDef.code,
                                description: funcDef.description || ""
                            });
                        }
                    });
                }
                return msg;
            } catch (err) {
                node.error("Error in processWithFunctions: " + err.toString());
                return msg;
            }
        }

        // Function to connect to MQTT using global config
        const connectToMqtt = async () => {
            try {
                if (this.client) {
                    console.log("Closing existing MQTT connection");
                    await new Promise((resolve) => {
                        this.client.end(true, () => {
                            console.log("Existing MQTT connection closed");
                            resolve();
                        });
                    });
                }

                // Get the global MQTT configuration
                let globalConfig = RED.settings.globalMqttConfig;
                console.log("Retrieved MQTT Config:", globalConfig);

                if (!globalConfig || !globalConfig.broker) {
                    console.log("Global MQTT broker not configured, using defaults");
                    globalConfig = {
                        broker: "localhost",
                        port: "1883"
                    };
                }

                // Create MQTT client options
                var options = {
                    clientId: 'unit_node_' + Math.random().toString(16).substring(2, 8),
                    clean: true,
                    reconnectPeriod: 5000
                };

                // Get connection details from global config
                var brokerUrl = 'mqtt://' + globalConfig.broker + ':' + (globalConfig.port || '1883');
                console.log("Connecting to MQTT broker:", brokerUrl);
                
                // Create MQTT client
                this.client = mqtt.connect(brokerUrl, options);
                
                if (this.client) {
                    this.client.on('connect', () => {
                        console.log("Connected to MQTT broker");
                        node.status({fill:"green", shape:"dot", text:"mqtt connected"});
                        
                        if (node.topic) {
                            node.client.subscribe(node.topic, {qos: node.qos}, (err) => {
                                if (err) {
                                    console.log("Error subscribing to topic:", err);
                                    node.error("Failed to subscribe to topic: " + err.toString());
                                } else {
                                    console.log("Subscribed to topic:", node.topic);
                                }
                            });
                        } else {
                            node.warn("MQTT topic not specified");
                        }
                    });

                    this.client.on('message', function(topic, message) {
                        try {
                            var msg = {
                                topic: topic,
                                payload: message.toString()
                            };
                            
                            try {
                                msg.payload = JSON.parse(msg.payload);
                            } catch (parseError) {
                                node.warn("MQTT message is not valid JSON, using as string");
                            }

                            // Add debug message to global debug log
                            RED.comms.publish("debug", {
                                id: node.id,
                                z: node.z,
                                _alias: node._alias,
                                path: node._flow.path,
                                name: node.name || "unit-node",
                                topic: topic,
                                msg: {
                                    topic: topic,
                                    payload: msg.payload
                                }
                            });
                            
                            msg.processed_by_unit_node = true;
                            
                            // Process with functions if defined
                            msg = processWithFunctions(msg);
                            
                            var generatedTriplets = [];
                            var storeTriplets = [];
                            
                            node.templates.forEach(function(template) {
                                if (template.subject && template.predicate && template.object) {
                                    var triplet = {
                                        subject: template.subject,
                                        predicate: template.predicate,
                                        object: template.object
                                    };
                                    
                                    if (typeof msg.payload === 'object') {
                                        for (var key in triplet) {
                                            if (triplet[key].startsWith('msg.')) {
                                                var path = triplet[key].substring(4).split('.');
                                                var value = msg;
                                                
                                                for (var i = 0; i < path.length; i++) {
                                                    if (value === undefined || value === null) break;
                                                    value = value[path[i]];
                                                }
                                                
                                                if (value !== undefined && value !== null) {
                                                    triplet[key] = value.toString();
                                                }
                                            }
                                        }
                                    }
                                    
                                    generatedTriplets.push(triplet);
                                    
                                    if (template.enableStorage && node.apiEndpoint) {
                                        storeTriplets.push(triplet);
                                    }
                                }
                            });
                            
                            if (generatedTriplets.length > 0) {
                                if (!msg["unit-node"]) {
                                    msg["unit-node"] = [];
                                }
                                
                                msg["unit-node"] = msg["unit-node"].concat(generatedTriplets);
                                
                                if (node.prompt) {
                                    msg.prompt = node.prompt;
                                    
                                    generatedTriplets.forEach(function(triplet) {
                                        msg.prompt += "\nTriplet: " + triplet.subject + " - " + triplet.predicate + " - " + triplet.object;
                                    });
                                }
                                
                                if (storeTriplets.length > 0 && node.apiEndpoint) {
                                    try {
                                        var storageRequest = {
                                            "unit-node": storeTriplets,
                                            timestamp: new Date().toISOString()
                                        };
                                        
                                        node.warn("Would store " + storeTriplets.length + " triplets to: " + node.apiEndpoint);
                                        node.status({fill:"blue", shape:"dot", text:"mqtt: storing " + storeTriplets.length});
                                    } catch (storeError) {
                                        node.error("Error storing triplets: " + storeError.toString());
                                    }
                                }
                            }
                            
                            if (node.prompt && !msg.prompt) {
                                msg.prompt = node.prompt;
                                if (typeof msg.payload === 'object') {
                                    msg.payload.prompt = node.prompt;
                                }
                            }
                            
                            if (node.objective) {
                                msg.objective = node.objective;
                                if (typeof msg.payload === 'object') {
                                    msg.payload.objective = node.objective;
                                }
                            }
                            
                            node.send(msg);
                            
                        } catch (err) {
                            node.error("Error processing MQTT message: " + err.toString());
                        }
                    });

                    this.client.on('error', function(err) {
                        console.log("MQTT error:", err);
                        node.status({fill:'red', shape:'ring', text:'mqtt error: ' + err.message});
                        node.error("MQTT error: " + err.toString());
                    });

                    this.client.on('close', function() {
                        console.log("MQTT connection closed");
                        node.status({fill:'red', shape:'ring', text:'mqtt disconnected'});
                    });

                    this.client.on('reconnect', function() {
                        console.log("Attempting to reconnect to MQTT broker");
                        node.status({fill:'yellow', shape:'ring', text:'mqtt reconnecting'});
                    });
                } else {
                    node.error("Failed to create MQTT client");
                    this.status({fill:'red', shape:'ring', text:'mqtt client creation failed'});
                }
            } catch (err) {
                console.error("Error creating MQTT client:", err);
                node.error("Error creating MQTT client: " + err.toString());
                this.status({fill:'red', shape:'ring', text:'mqtt setup error'});
            }
        };

        // Listen for global MQTT config changes
        this.globalMqttConfigListener = function(config) {
            console.log("Node", node.id, "received MQTT config update:", config);
            if (config && (config.broker !== node.broker || config.port !== node.port)) {
                node.broker = config.broker;
                node.port = config.port;
                console.log("Node", node.id, "reconnecting with new config:", config);
                connectToMqtt().catch(err => {
                    console.error("Error reconnecting after config update:", err);
                });
            }
        };

        // Register for MQTT config updates
        RED.events.on("global-mqtt-config:update", this.globalMqttConfigListener);

        // Store initial broker and port
        this.broker = RED.settings.globalMqttConfig?.broker || "localhost";
        this.port = RED.settings.globalMqttConfig?.port || "1883";

        // Initial connection with delay to ensure settings are loaded
        setTimeout(() => {
            connectToMqtt().catch(err => {
                console.error("Error in initial MQTT connection:", err);
            });
        }, 2000);

        // Store function definitions but don't try to execute Python code
        // Just store them as documentation/reference for tools
        if (this.functions.length > 0) {
            this.functions.forEach(function(functionDef) {
                node.functionObjects.push({
                    name: functionDef.name,
                    code: functionDef.code // Just store the code as is
                });

                // add functionDef to the doxigen_data.json file if the function does not already exist 
                // if the file does not exist, create it
                // define the path to the doxigen_data.json file
                const doxigenDataPath = path.join(RED.settings.userDir, 'public', 'data', 'custom_doxigen_data.json');
                if (!fs.existsSync(doxigenDataPath)) {
                    fs.writeFileSync(doxigenDataPath, JSON.stringify({ tools: [] }, null, 2));
                }

                // Read existing data
                var doxigenData = JSON.parse(fs.readFileSync(doxigenDataPath, 'utf8'));
                if (!doxigenData.tools) doxigenData.tools = [];

                // Get new functions that aren't in the JSON file already
                const existingFunctionNames = doxigenData.tools.map(tool => tool.name);
                const newFunctions = config.functions.filter(func => !existingFunctionNames.includes(func.name));

                // Add only new functions to the tools array
                newFunctions.forEach(func => {
                    doxigenData.tools.push(func);
                });

                // Write updated data back to the file
                fs.writeFileSync(doxigenDataPath, JSON.stringify(doxigenData, null, 2));
                
                
            });
        }

        // Handle normal input flow messages
        this.on("input", function(msg, send, done) {
            // Apply configured payload if set
            if (node.payload) {
                msg.payload = node.payload;
            }
            
            // Mark message as processed
            msg.processed_by_unit_node = true;
            
            // Process with tools
            try {
                msg = processWithFunctions(msg);
            } catch (err) {
                node.error("Error running tools: " + err.toString(), msg);
            }
            
            // Create a text representation of triplet templates to add to the prompt
            var templatesText = "Knowledge Triplet Templates:\n";
            
            node.templates.forEach(function(template) {
                templatesText += `${template.subject} ${template.predicate} [${template.object}]\n`;
            });
            
            // Store the templates text for use in the prompt
            msg.templatesText = templatesText;
            
            // Store the original prompt if set
            var originalPrompt = node.prompt || '';
            
            // If prompt is already set, append the templates
            if (originalPrompt) {
                msg.prompt = originalPrompt + "\n\n" + templatesText;
            } else {
                msg.prompt = templatesText;
            }
            
            // Also add to payload for easier access
            if (typeof msg.payload === 'object') {
                msg.payload.templatesText = templatesText;
                msg.payload.prompt = msg.prompt;
            }
            
            var triplets = [];
            var storeTriplets = []; // Separate array for triplets to be stored
            var data = {};
            
            // Extract data from payload
            if (typeof msg.payload === 'object') {
                data = msg.payload;
            } else if (typeof msg.payload === 'string') {
                try {
                    data = JSON.parse(msg.payload);
                } catch(e) {
                    data = { value: msg.payload };
                }
            } else {
                data = { value: msg.payload };
            }
            
            // Process each template to extract triplets
            node.templates.forEach(function(template) {
                // Extract path from object field if it exists
                if (template.subject && template.predicate && template.object) {
                    var objectPath = template.object;
                    var value;
                    
                    // Handle dynamic paths (msg.payload.something)
                    if (objectPath.startsWith('msg.')) {
                        var path = objectPath.substring(4).split('.');
                        value = msg;
                        
                        // Navigate the path
                        for (var i = 0; i < path.length; i++) {
                            if (value === undefined || value === null) break;
                            value = value[path[i]];
                        }
                    } else {
                        // Try direct access from data
                        value = data[objectPath];
                    }
                    
                    // Create the triplet if value was found
                    if (value !== undefined && value !== null) {
                        // Convert to string if needed
                        if (typeof value !== 'string') {
                            value = value.toString();
                        }
                        
                        var triplet = {
                            subject: template.subject,
                            predicate: template.predicate,
                            object: value
                        };
                        
                        // Add to all triplets array
                        triplets.push(triplet);
                        
                        // If this template has storage enabled, add to the store array
                        if (template.enableStorage && node.apiEndpoint) {
                            storeTriplets.push(triplet);
                        }
                    }
                }
            });
            
            // Add triplets to message for storage and other uses
            msg["unit-node"] = triplets;
            
            // Store triplets that are marked for storage
            if (storeTriplets.length > 0 && node.apiEndpoint) {
                try {
                    // Create storage request
                    var storageMsg = {
                        url: node.apiEndpoint,
                        method: "POST",
                        payload: {
                            "unit-node": storeTriplets,
                            timestamp: new Date().toISOString()
                        }
                    };
                    
                    // Log the storage attempt
                    node.status({fill:"green", shape:"dot", text:"storing triplets: " + storeTriplets.length});
                    
                    // Include storage message
                    msg.storageRequest = storageMsg;
                } catch(err) {
                    node.error("Error preparing storage: " + err.toString(), msg);
                    node.status({fill:"red", shape:"ring", text:"storage error"});
                }
            }
            
            // Include prompt and objective if set (only if not already set by triplets)
            if (node.prompt && !msg.prompt) {
                msg.prompt = node.prompt;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.prompt = node.prompt;
                }
            }
            
            if (node.objective) {
                msg.objective = node.objective;
                // Also add to payload for easier access
                if (typeof msg.payload === 'object') {
                    msg.payload.objective = node.objective;
                }
            }
            
            // Handle MQTT topic changes - always enabled
            if (node.client && msg.mqtt_control) {
                if (msg.mqtt_control === 'subscribe' && msg.topic) {
                    // Subscribe to a new topic
                    try {
                        if (node.topic) {
                    node.client.unsubscribe(node.topic);
                        }
                        node.topic = msg.topic;
                        node.client.subscribe(node.topic, {qos: node.qos});
                        node.status({fill:"green", shape:"dot", text:"mqtt: " + node.topic});
                    } catch(err) {
                        node.error("Error changing subscription: " + err.toString());
                    }
                }
                else if (msg.mqtt_control === 'unsubscribe') {
                    // Unsubscribe from current topic
                    try {
                        if (node.topic) {
                            node.client.unsubscribe(node.topic);
                            node.topic = '';
                            node.status({fill:"yellow", shape:"dot", text:"mqtt: no subscription"});
                        }
                    } catch(err) {
                        node.error("Error unsubscribing: " + err.toString());
                    }
                }
            }
            
            // Send the message using the helper function
            sendAndUpdatePreview(msg); // Send handled by helper

            if (done) {
                done();
            }
        });

        // Clean up subscription when node is removed
        this.on('close', function(done) {
            if (this.globalMqttConfigListener) {
                RED.events.removeListener("global-mqtt-config:update", this.globalMqttConfigListener);
            }
            if (this.client) {
                this.client.end(true, done);
            } else {
                done();
            }
        });
    }
    RED.nodes.registerType("unit-node", UnitNode);
}