RED.contextMenu = (function () {

    let menu;
    let edgeConditions = {};

    // Add a direct implementation of editDialog if it doesn't exist in RED.editor
    if (!RED.editor) {
        RED.editor = {};
    }
    
    if (!RED.editor.editDialog) {
        RED.editor.editDialog = function(options) {
            // Create a jQuery UI dialog with the provided options
            var dialogOptions = {
                modal: true,
                width: 'auto',
                height: 'auto',
                autoOpen: true,
                resizable: false,
                classes: options.dialogClass,
                title: options.title || "Dialog",
                open: options.open,
                close: options.beforeClose,
                position: options.position || { my: "center", at: "center", of: window }
            };
            
            // Create dialog container
            var dialog = $('<div></div>').appendTo('body');
            
            // Add content
            if (options.body) {
                options.body.appendTo(dialog);
            }
            
            // Add buttons if provided
            if (options.buttons && options.buttons.length > 0) {
                var buttons = {};
                options.buttons.forEach(function(btn) {
                    buttons[btn.id] = {
                        text: btn.text,
                        class: btn.class || '',
                        click: btn.click
                    };
                });
                dialogOptions.buttons = buttons;
            }
            
            // Initialize the dialog
            dialog.dialog(dialogOptions);
            
            return dialog;
        };
    }

    function showConnectionDialog(link, condition) {
        // --- Data Initialization and Migration ---
        condition = condition || {};
        condition.enabled = true; // Always enabled for editing

        // --- NEW Migration Logic ---
        let migratedLogical = { logic: 'and', conditions: [] };
        let migratedPrompt = { conditions: [] };

        if (condition.logical || condition.prompt) {
            // Already has new structure (or parts of it)
            migratedLogical = condition.logical || migratedLogical;
            migratedLogical.logic = migratedLogical.logic || 'and'; // Ensure logic default
            migratedLogical.conditions = migratedLogical.conditions || [];
            migratedPrompt = condition.prompt || migratedPrompt;
            migratedPrompt.conditions = migratedPrompt.conditions || [];
        } else if (Array.isArray(condition.conditions)) {
             // Migrate from old array structure (previously condition.logical.conditions)
             migratedLogical.conditions = condition.conditions;
             migratedLogical.logic = condition.logic || 'and'; // Use old logic if present
        } else if (condition.property || condition.operator) {
             // Migrate from very old property/operator structure (IGNORE - cannot map to triplets)
             console.warn("[showConnectionDialog] Discarding legacy non-triplet condition format:", JSON.stringify(condition));
             // Keep migratedLogical/Prompt empty
        } else if (condition.tripletSubject || condition.tripletPredicate || condition.tripletObject) {
             // Migrate from old single-triplet format
            migratedLogical.conditions.push({
                subject: condition.tripletSubject || '',
                predicate: condition.tripletPredicate || '',
                object: condition.tripletObject || '',
                operator: 'eq', // Default operator
                value: ''       // Default value
            });
        }
        // Overwrite original condition object with potentially migrated/initialized structure
        condition = {
            enabled: condition.enabled, // Preserve original enabled state if needed, though we set it true anyway
            logical: migratedLogical,
            prompt: migratedPrompt
        };
        // --- End NEW Migration Logic ---

        // Ensure defaults one last time (belt and braces)
        condition.logical.logic = condition.logical.logic || 'and';
        condition.prompt.conditions = condition.prompt.conditions || [];

        // --- Gather Triplet Data from Unit Nodes ---
        let tripletMap = {};
        let uniqueSubjects = new Set();
        RED.nodes.eachNode(function(node) {
            if (node.type === 'unit-node' && Array.isArray(node.templates)) {
                node.templates.forEach(function(template) {
                    if (template.subject && template.predicate && template.object) {
                        uniqueSubjects.add(template.subject);
                        if (!tripletMap[template.subject]) {
                            tripletMap[template.subject] = {};
                        }
                        if (!tripletMap[template.subject][template.predicate]) {
                            tripletMap[template.subject][template.predicate] = new Set(); // Use Set for unique objects
                        }
                        tripletMap[template.subject][template.predicate].add(template.object);
                    }
                });
            }
        });
        // Convert Sets to sorted Arrays for dropdowns
        let sortedSubjects = Array.from(uniqueSubjects).sort();
        for (const subject in tripletMap) {
            for (const predicate in tripletMap[subject]) {
                tripletMap[subject][predicate] = Array.from(tripletMap[subject][predicate]).sort();
            }
        }
        // console.log("Triplet Map:", tripletMap);
        // --- End Gather Triplet Data ---

        // --- Dialog Structure ---
        var dialogContent = $('<div class="red-ui-connection-dialog dialog-form"></div>');

        // --- Toggle Buttons Row ---
        var toggleRow = $('<div class="form-row red-ui-connection-dialog-toggle-row"></div>').appendTo(dialogContent);
        var logicalButton = $('<button type="button" class="red-ui-button red-ui-connection-dialog-toggle-button active" data-section="logical">Logical Conditions</button>').appendTo(toggleRow);
        var promptButton = $('<button type="button" class="red-ui-button red-ui-connection-dialog-toggle-button" data-section="prompt">Prompt Conditions</button>').appendTo(toggleRow);

        // --- Content Panes ---
        var logicalContentPane = $('<div id="red-ui-connection-dialog-pane-logical" class="red-ui-connection-dialog-pane"></div>').appendTo(dialogContent);
        var promptContentPane = $('<div id="red-ui-connection-dialog-pane-prompt" class="red-ui-connection-dialog-pane" style="display: none;"></div>').appendTo(dialogContent); // Initially hidden

        // --- Build Logical Conditions Section (Modified) ---
        function buildLogicalSection() {
            logicalContentPane.empty();
            var logicRow = $('<div class="form-row"></div>').appendTo(logicalContentPane);
            
            var logicContainer = $('<span/>').appendTo(logicRow);
            var andRadioId = 'node-edge-logic-and-' + link.source.id + '-' + link.target.id;
            var orRadioId = 'node-edge-logic-or-' + link.source.id + '-' + link.target.id;

            // --- Fix Radio Button/Label association ---
            // AND Button
            var andInput = $('<input type="radio" name="node-edge-logic" value="and" style="margin-left: 7px; margin-right: 5px;">');
            andInput.attr('id', andRadioId); // Set ID
            andInput.prop('checked', condition.logical.logic === 'and');
            var andLabel = $('<label style="margin-right: 15px;">AND</label>');
            andLabel.attr('for', andRadioId); // Set for attribute to match ID
            logicContainer.append(andInput);
            logicContainer.append(andLabel);

            // OR Button
            var orInput = $('<input type="radio" name="node-edge-logic" value="or" style="margin-right: 5px;">');
            orInput.attr('id', orRadioId); // Set ID
            orInput.prop('checked', condition.logical.logic === 'or');
            var orLabel = $('<label>OR</label>');
            orLabel.attr('for', orRadioId); // Set for attribute to match ID
            logicContainer.append(orInput);
            logicContainer.append(orLabel);
            // --- End Fix ---

            var conditionsContainer = $('<div id="logical-conditions-list" class="red-ui-connection-dialog-conditions"></div>').appendTo(logicalContentPane);

            function addLogicalConditionRow(conditionData) {
                var rowId = 'logical-condition-row-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
                var conditionRow = $('<div class="red-ui-connection-dialog-condition-row logical-condition-row" id="' + rowId + '"></div>').appendTo(conditionsContainer);
                
                // Apply flex display and alignment directly to the fields container
                var fieldsContainer = $('<div class="red-ui-connection-dialog-condition-fields"></div>')
                    .css({
                        'display': 'flex',
                        'align-items': 'flex-end', // Align items to the bottom
                        'gap': '10px',            // Space between items
                        'flex-wrap': 'wrap'        // Allow wrapping if needed
                    })
                    .appendTo(conditionRow);

                // Helper to create a dropdown group
                function createDropdownGroup(label, specificClass = '') {
                    var group = $('<div class="red-ui-connection-dialog-input-group ' + specificClass + '" style="flex: 1; min-width: 120px;"></div>'); // Increased min-width
                    $('<label style="display: block; margin-bottom: 2px;">' + label + '</label>').appendTo(group);
                    return group;
                }

                // --- Subject Dropdown ---
                var subjectGroup = createDropdownGroup('Subject').appendTo(fieldsContainer);
                var subjectSelect = $('<select class="condition-subject" style="width: 100%;"></select>').appendTo(subjectGroup);
                subjectSelect.append('<option value="">-- Subject --</option>');
                sortedSubjects.forEach(subj => subjectSelect.append('<option value="' + subj + '">' + subj + '</option>'));

                // --- Predicate Dropdown ---
                var predicateGroup = createDropdownGroup('Predicate').appendTo(fieldsContainer);
                var predicateSelect = $('<select class="condition-predicate" style="width: 100%;"></select>').appendTo(predicateGroup);
                predicateSelect.append('<option value="">-- Predicate --</option>'); // Initially empty

                // --- Object Dropdown ---
                var objectGroup = createDropdownGroup('Object').appendTo(fieldsContainer);
                var objectSelect = $('<select class="condition-object" style="width: 100%;"></select>').appendTo(objectGroup);
                objectSelect.append('<option value="">-- Object --</option>'); // Initially empty

                // --- Operator Dropdown (Remains the same) ---
                var operatorGroup = createDropdownGroup('Operator', 'operator-group').appendTo(fieldsContainer);
                var operatorSelect = $('<select class="condition-operator" style="width: 100%;"></select>').appendTo(operatorGroup);
            var operators = [
                    { value: "eq", label: "==" }, { value: "neq", label: "!=" }, { value: "contains", label: "contains" },
                    { value: "startsWith", label: "starts with" }, { value: "endsWith", label: "ends with" }, { value: "exists", label: "exists" },
                    { value: "matches", label: "matches regex" }, { value: "lt", label: "<" }, { value: "lte", label: "<=" },
                    { value: "gt", label: ">" }, { value: "gte", label: ">=" },
                ];
                operators.forEach(op => operatorSelect.append('<option value="' + op.value + '">' + op.label + '</option>'));
                operatorSelect.val(conditionData.operator || 'eq');

                // --- Value Input (Remains the same) ---
                var valueGroup = createDropdownGroup('Value').appendTo(fieldsContainer);
                $('<input type="text" class="condition-value" placeholder="(Value)" style="width: 100%;">')
                    .val(conditionData.value || '')
                    .appendTo(valueGroup);

                // Delete Button
                var buttonContainer = $('<div class="red-ui-connection-dialog-delete-btn-container" style="flex-shrink: 0; margin-left: 5px;"></div>').appendTo(fieldsContainer);
                $('<button type="button" class="red-ui-button red-ui-button-small"><i class="fa fa-trash"></i></button>')
                    .appendTo(buttonContainer)
                    .on('click', function() { $('#' + rowId).remove(); });

                // --- Cascading Logic --- 
                subjectSelect.on('change', function() {
                    var selectedSubject = $(this).val();
                    var availablePredicates = selectedSubject && tripletMap[selectedSubject] ? Object.keys(tripletMap[selectedSubject]).sort() : [];
                    
                    // Clear and repopulate predicate dropdown
                    predicateSelect.empty().append('<option value="">-- Predicate --</option>');
                    availablePredicates.forEach(pred => predicateSelect.append('<option value="' + pred + '">' + pred + '</option>'));
                    
                    // Clear object dropdown as well
                    objectSelect.empty().append('<option value="">-- Object --</option>');
                    
                    // Optional: If editing existing, re-select predicate if it's still valid
                     if (conditionData && availablePredicates.includes(conditionData.predicate)) {
                          predicateSelect.val(conditionData.predicate);
                     }
                    predicateSelect.trigger('change'); // Trigger change to update object dropdown
                });

                predicateSelect.on('change', function() {
                    var selectedSubject = subjectSelect.val(); // Get subject from the same row
                    var selectedPredicate = $(this).val();
                    var availableObjects = selectedSubject && selectedPredicate && tripletMap[selectedSubject] && tripletMap[selectedSubject][selectedPredicate] ? tripletMap[selectedSubject][selectedPredicate] : [];
                    
                    // Clear and repopulate object dropdown
                    objectSelect.empty().append('<option value="">-- Object --</option>');
                    availableObjects.forEach(obj => objectSelect.append('<option value="' + obj + '">' + obj + '</option>'));

                    // Optional: If editing existing, re-select object if it's still valid
                     if (conditionData && availableObjects.includes(conditionData.object)) {
                         objectSelect.val(conditionData.object);
                     }
                });

                // --- Set Initial Values for Existing Conditions ---
                if (conditionData) {
                    if (sortedSubjects.includes(conditionData.subject)) {
                         subjectSelect.val(conditionData.subject); // Set subject value
                         subjectSelect.trigger('change'); // Trigger change *after* setting value
                    } else {
                        // Handle case where saved subject is no longer valid? Maybe add it as a disabled option?
                        console.warn('Saved subject "' + conditionData.subject + '" not found in current unit-node templates.');
                        subjectSelect.trigger('change'); // Still trigger to potentially clear lower dropdowns
                    }
                    // Note: Predicate and Object values are set *within* the change handlers after they are populated.
                }

                return conditionRow;
            }
            
            if (condition.logical.conditions && condition.logical.conditions.length > 0) {
                condition.logical.conditions.forEach(addLogicalConditionRow);
            } else {
                addLogicalConditionRow({});
            }
            
            var addButtonRow = $('<div class="form-row" style="margin-top: 15px;"></div>').appendTo(logicalContentPane);
            $('<button type="button" class="red-ui-button"><i class="fa fa-plus" style="margin-right: 5px;"></i> Add Logical Condition</button>')
                .appendTo(addButtonRow)
                .on('click', function() { addLogicalConditionRow({}); });
        }

        // --- Build Prompt Conditions Section ---
        function buildPromptSection() {
            promptContentPane.empty();
            $('<div class="form-row" style="margin-bottom: 15px;"><div class="form-tips"><i class="fa fa-info-circle"></i> Define prompts that must be satisfied for a message to pass. All prompt conditions must be met.</div></div>').appendTo(promptContentPane);
            var promptsContainer = $('<div id="prompt-conditions-list" class="red-ui-connection-dialog-conditions"></div>').appendTo(promptContentPane);

            function addPromptConditionRow(promptText) {
                promptText = promptText || '';
                var rowId = 'prompt-condition-row-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
                var conditionRow = $('<div class="red-ui-connection-dialog-condition-row prompt-condition-row" id="' + rowId + '"></div>').appendTo(promptsContainer);
                var fieldsContainer = $('<div class="red-ui-connection-dialog-condition-fields" style="align-items: center;"></div>').appendTo(conditionRow);

                var inputContainer = $('<div class="red-ui-connection-dialog-input-group" style="flex-grow: 1;"></div>').appendTo(fieldsContainer);
                $('<label>Prompt</label>').appendTo(inputContainer);
                var promptInput = $('<input type="text" class="condition-prompt-input" readonly placeholder="(Click to edit prompt)" style="cursor: pointer;">')
                    .appendTo(inputContainer)
                    .data('full-prompt', promptText)
                    .val(promptText.length > 60 ? promptText.substring(0, 57) + '...' : promptText)
                    .on('click', function() {
                        var currentInput = $(this);
                        var currentPrompt = currentInput.data('full-prompt') || '';

                        // --- Create a dedicated modal dialog for editing the prompt --- 
                        var editContainer = $('<div>').css({'padding': '10px'});
                        var promptTextArea = $('<textarea style="width: 100%; height: 200px; font-family: monospace;"></textarea>')
                            .val(currentPrompt)
                            .appendTo(editContainer);

                        editContainer.dialog({
                            title: "Edit Prompt Condition",
                            modal: true, // Make sure it's modal
                            width: 600, // Adjust size as needed
                            resizable: false,
                            classes: {
                                "ui-dialog": "red-ui-editor-dialog" // Use standard class for consistency
                            },
                            buttons: [
                                {
                                    text: RED._("common.label.save"),
                                    class: "primary",
                                    click: function() {
                                        var newPrompt = promptTextArea.val();
                                        currentInput.data('full-prompt', newPrompt);
                                        currentInput.val(newPrompt.length > 60 ? newPrompt.substring(0, 57) + '...' : newPrompt);
                                        $(this).dialog("close");
                                    }
                                },
                                {
                                    text: RED._("common.label.cancel"),
                                    click: function() {
                                        $(this).dialog("close");
                                    }
                                }
                            ],
                            close: function() {
                                // Ensure the temporary dialog is destroyed on close
                                $(this).dialog('destroy').remove();
                            }
                        });
                        // --- End of dedicated modal dialog ---
                    });

                var buttonContainer = $('<div class="red-ui-connection-dialog-delete-btn-container"></div>').appendTo(fieldsContainer);
                $('<button type="button" class="red-ui-button red-ui-button-small"><i class="fa fa-trash"></i></button>')
                    .appendTo(buttonContainer)
                    .on('click', function() { $('#' + rowId).remove(); });

                return conditionRow;
            }
            
            if (condition.prompt.conditions && condition.prompt.conditions.length > 0) {
                condition.prompt.conditions.forEach(addPromptConditionRow);
            } else {
                 addPromptConditionRow("");
            }
            
            var addButtonRow = $('<div class="form-row" style="margin-top: 15px;"></div>').appendTo(promptContentPane);
            $('<button type="button" class="red-ui-button"><i class="fa fa-plus" style="margin-right: 5px;"></i> Add Prompt Condition</button>')
                .appendTo(addButtonRow)
                .on('click', function() { addPromptConditionRow(''); });
        }

        // --- Build Sections ---
        buildLogicalSection();
        buildPromptSection();

        // --- Toggle Logic ---
        function switchSection(section) {
            if (section === 'logical') {
                promptContentPane.hide();
                logicalContentPane.show();
                logicalButton.addClass('active');
                promptButton.removeClass('active');
            } else if (section === 'prompt') {
                logicalContentPane.hide();
                promptContentPane.show();
                promptButton.addClass('active');
                logicalButton.removeClass('active');
            }
            // Optional: Trigger resize if content height differs significantly
            // $(window).trigger('resize');
        }

        logicalButton.on('click', function() { switchSection('logical'); });
        promptButton.on('click', function() { switchSection('prompt'); });

        // --- Save Function (Modified for selects) ---
                function saveChanges() {
                    var newCondition = {
                        enabled: true,
                logical: {
                    logic: $('#red-ui-connection-dialog-pane-logical input[name="node-edge-logic"]:checked').val() || 'and',
                        conditions: []
                },
                prompt: {
                    conditions: []
                }
                    };
                    
            // Collect Logical Conditions
            $('#logical-conditions-list .logical-condition-row').each(function() {
                        var row = $(this);
                var logCond = {
                    subject: row.find('.condition-subject').val(), // Read from select
                    predicate: row.find('.condition-predicate').val(), // Read from select
                    object: row.find('.condition-object').val(), // Read from select
                            operator: row.find('.condition-operator').val(),
                    value: row.find('.condition-value').val().trim()
                };
                 console.log("[saveChanges] Processing logical condition row:", JSON.stringify(logCond)); // DEBUG LOG
                 // Only add if subject, predicate, and object are selected (basic validation)
                if (logCond.subject && logCond.predicate && logCond.object) { 
                    newCondition.logical.conditions.push(logCond);
                    console.log("[saveChanges]   -> Added logical condition."); // DEBUG LOG
                } else {
                    console.log("[saveChanges]   -> Skipped logical condition (Subject/Predicate/Object not fully selected)."); // DEBUG LOG
                }
            });

            // Collect Prompt Conditions
            $('#prompt-conditions-list .prompt-condition-row').each(function() {
                var row = $(this);
                var promptInput = row.find('.condition-prompt-input');
                var promptText = promptInput.data('full-prompt')?.trim(); // Use optional chaining
                console.log("[saveChanges] Processing prompt condition row:", rowId = row.attr('id')); // DEBUG LOG
                console.log("[saveChanges]   -> Retrieved prompt data:", promptInput.data('full-prompt')); // DEBUG LOG
                console.log("[saveChanges]   -> Trimmed prompt text:", promptText); // DEBUG LOG
                if (promptText) { // Only add non-empty prompts
                    newCondition.prompt.conditions.push(promptText);
                    console.log("[saveChanges]   -> Added prompt condition."); // DEBUG LOG
                } else {
                    console.log("[saveChanges]   -> Skipped prompt condition (empty)."); // DEBUG LOG
                }
                    });
                    
                    // Save the link condition
                    var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
                    edgeConditions[linkId] = newCondition;
                    
                    updateLinkAppearance(link, newCondition);
                    RED.nodes.dirty(true);
            saveEdgeConditionsToFlow(); // Persist changes
            RED.notify("Connection conditions saved", "success", null, 3000);
                    
                    return newCondition;
                }
                
        // --- Dialog Creation ---
        var dialog = $('<div></div>').html(dialogContent).dialog({
            title: "Edit Connection Conditions",
                    modal: true,
                    autoOpen: true,
            width: 850,
            minWidth: 650,
            maxHeight: $(window).height() * 0.85,
            resizable: true,
                    classes: {
                "ui-dialog": "red-ui-editor-dialog red-ui-connection-dialog-container" 
                    },
                    buttons: [
                        {
                    id: "node-dialog-ok",
                    text: RED._("common.label.save"),
                    class: "primary",
                    click: function() {
                                saveChanges();
                                $(this).dialog("close");
                            }
                        },
                        {
                            id: "node-dialog-cancel",
                    text: RED._("common.label.cancel"),
                            click: function() {
                                $(this).dialog("close");
                            }
                        }
                    ],
                    close: function() {
                        $(this).dialog('destroy').remove();
            },
            open: function(event, ui) {
                $(this).css('overflow', 'auto'); // Allow dialog content to scroll if needed
            }
        });
    }
    
    // Update the link appearance based on whether it has conditions enabled
    function updateLinkAppearance(link, condition) {
        var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
        var linkElement = $('.red-ui-flow-link[id$="' + linkId + '"]');
        
        if (condition.enabled) {
            // Make the link dashed to show it's conditional
            linkElement.css('stroke-dasharray', '5,2');
            
            // Add a class for later reference
            linkElement.addClass('red-ui-conditional-link');
            
            // Store data on the link for evaluation
            link._condition = condition;
        } else {
            // Reset to solid line
            linkElement.css('stroke-dasharray', 'none');
            
            // Remove the class
            linkElement.removeClass('red-ui-conditional-link');
            
            // Remove the condition data
            delete link._condition;
        }
    }

    // Evaluate a condition against a message
    function evaluateCondition(condition, msg) {
        if (!condition || !condition.enabled) {
            return true; // If condition is disabled or missing, always pass
        }

        let logicalResult = true;
        let promptResult = true;

        // --- Evaluate Logical Conditions ---
        if (condition.logical && condition.logical.conditions && condition.logical.conditions.length > 0) {
            if (!msg.triplets || !Array.isArray(msg.triplets)) {
                logicalResult = false; // Need triplets to evaluate logical conditions
        } else {
                logicalResult = evaluateTripletCondition(condition.logical, msg.triplets); // Pass the logical part
            }
        }

        // --- Evaluate Prompt Conditions --- (Needs specific implementation based on requirements)
        if (condition.prompt && condition.prompt.conditions && condition.prompt.conditions.length > 0) {
            // Placeholder: How should prompts be evaluated?
            // Option 1: Against triplets (e.g., does any triplet object contain the prompt?)
            // Option 2: Against msg.payload directly?
            // Option 3: Passed to an external service/LLM?
            // For now, let's assume they must also pass, but implement a simple check.
            // This part NEEDS CLARIFICATION based on desired behavior.

            let allPromptsPass = true;
            for (const promptText of condition.prompt.conditions) {
                let promptPasses = false;
                // Example: Check if prompt exists somewhere in the message (simple check)
                if (JSON.stringify(msg).includes(promptText)) {
                     promptPasses = true;
                }
                // Example: Check against triplets (if any triplet object contains prompt)
                // if (msg.triplets && msg.triplets.some(t => String(t.object).includes(promptText))) {
                //     promptPasses = true;
                // }

                if (!promptPasses) {
                    allPromptsPass = false;
                    break; // One failed prompt means the overall prompt section fails
                }
            }
            promptResult = allPromptsPass;
        }

        // Combine results (defaulting to AND)
        return logicalResult && promptResult;
    }

    // Evaluate a triplet-specific condition (Now takes condition.logical object)
    function evaluateTripletCondition(logicalCondition, triplets) {
        // If no triplets, the condition fails
        if (!triplets || !Array.isArray(triplets) || triplets.length === 0) {
            return false;
        }
        
        // Handle multiple conditions with AND/OR logic
        if (logicalCondition.conditions && logicalCondition.conditions.length > 0) {
            // For each condition, check if it matches any triplet
            var results = logicalCondition.conditions.map(function(cond) {
                // If all fields are empty, this condition is always true (matches any triplet)
                // This behavior might be debatable, consider if an empty condition should be false.
                if (!cond.subject && !cond.predicate && !cond.object && !cond.operator && !cond.value) {
                    return true;
                }
                
                // Check each triplet against this condition
                for (var i = 0; i < triplets.length; i++) {
                    var triplet = triplets[i];
                    
                    // Skip invalid triplets
                    if (!triplet || typeof triplet !== 'object') {
                        continue;
                    }
                    
                    // Check if this triplet matches the condition
                    if (matchesTripletCondition(triplet, cond)) {
                        // Found a match for this condition, no need to check other triplets
                        return true;
                    }
                }
                
                // No matches found for this condition
                return false;
            });
            
            // Apply logic (AND/OR)
            if (logicalCondition.logic === 'or') {
                // OR logic - any true result passes
                return results.some(function(result) { return result === true; });
            } else {
                // AND logic (default) - all results must be true
                return results.every(function(result) { return result === true; });
            }
        }
        
        // Fallback for old-style single condition format
        var subject = logicalCondition.tripletSubject;
        var predicate = logicalCondition.tripletPredicate;
        var object = logicalCondition.tripletObject;
        
        // Empty condition matches any triplet
        if (!subject && !predicate && !object) {
            return true;
        }
        
        // Check if any triplet matches the condition
        for (var i = 0; i < triplets.length; i++) {
            var triplet = triplets[i];
            
            // Skip invalid triplets
            if (!triplet || typeof triplet !== 'object') {
                continue;
            }
            
            // Check subject (if specified)
            if (subject && triplet.subject !== subject) {
                continue;
            }
            
            // Check predicate (if specified)
            if (predicate && triplet.predicate !== predicate) {
                continue;
            }
            
            // Check object (if specified)
            if (object && triplet.object !== object) {
                continue;
            }
            
            // If we got here, all specified conditions match
            return true;
        }
        
        // No matching triplet found
        return false;
    }
    
    // Helper function to check if a triplet matches a single condition
    function matchesTripletCondition(triplet, condition) {
        // Check subject (if specified) - Allow empty string to match anything
        if (condition.subject && triplet.subject !== condition.subject) {
            return false;
        }
        
        // Check predicate/field (if specified) - Allow empty string to match anything
        if (condition.predicate && triplet.predicate !== condition.predicate) { // Use predicate
            return false;
        }
        
        // Get the object value to check against
        var objectValue = triplet.object;
        
        // If object field is specified, only proceed if it matches - Allow empty string to match anything
        if (condition.object && objectValue !== condition.object) {
            return false;
        }
        
        // If we have a value to check against and an operator
        if (condition.value !== undefined && condition.value !== "" && condition.operator) {
            var targetValue = condition.value;
            var objValueAsString = String(objectValue);
            var targetValueAsString = String(targetValue);

            // Evaluate based on operator
            switch (condition.operator) {
                case 'eq':
                    return objValueAsString == targetValueAsString; // Compare as strings for simplicity unless types are handled
                case 'neq':
                    return objValueAsString != targetValueAsString;
                case 'contains':
                    return objValueAsString.includes(targetValueAsString);
                case 'startsWith':
                    return objValueAsString.startsWith(targetValueAsString);
                case 'endsWith':
                    return objValueAsString.endsWith(targetValueAsString);
                case 'exists':
                    // Check for existence and non-empty string value
                    return objectValue !== undefined && objectValue !== null && objValueAsString !== "";
                case 'matches':
                    try {
                        var regex = new RegExp(targetValue);
                        return regex.test(objValueAsString);
                    } catch(e) {
                        console.warn("Invalid regex in condition:", targetValue);
                        return false; // Invalid regex fails the match
                    }
                case 'lt': // Less than (numeric comparison)
                    return parseFloat(objectValue) < parseFloat(targetValue);
                case 'lte': // Less than or equal (numeric comparison)
                    return parseFloat(objectValue) <= parseFloat(targetValue);
                case 'gt': // Greater than (numeric comparison)
                    return parseFloat(objectValue) > parseFloat(targetValue);
                case 'gte': // Greater than or equal (numeric comparison)
                    return parseFloat(objectValue) >= parseFloat(targetValue);
                default:
                     console.warn("Unknown operator in condition:", condition.operator);
                    return true; // Default to true if operator is unknown? Or false? Let's default to true for now.
            }
        } else if (condition.operator === 'exists') {
             // Handle 'exists' operator even if value is empty
             return objectValue !== undefined && objectValue !== null && String(objectValue) !== "";
        }
        
        // If no specific operator/value check was performed (or needed), the condition parts matched so far
        return true;
    }
    
    // Save edge conditions to flow configuration
    function saveEdgeConditionsToFlow() {
        RED.settings.set('edgeConditions', edgeConditions);
    }
    
    // Load edge conditions from flow configuration
    function loadEdgeConditionsFromFlow() {
        var savedConditions = RED.settings.get('edgeConditions');
        console.log("[loadEdgeConditionsFromFlow] Loaded from settings:", JSON.stringify(savedConditions)); // DEBUG LOG
        if (savedConditions) {
            edgeConditions = savedConditions;
            
            // Apply conditions to links
            RED.nodes.eachLink(function(link) {
                var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
                if (edgeConditions[linkId]) {
                    updateLinkAppearance(link, edgeConditions[linkId]);
                }
            });
        }
    }
    
    // Apply conditions when messages are sent through links
    function setupConditionalWiring() {
        // Store the original RED.nodes.addLink function
        var originalAddLink = RED.nodes.addLink;
        
        // Override RED.nodes.addLink to add condition evaluation
        RED.nodes.addLink = function(link) {
            // Call the original function
            var result = originalAddLink.apply(this, arguments);
            
            // Get the link ID
            var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
            
            // If this link has a condition, store it on the link object
            if (edgeConditions[linkId] && edgeConditions[linkId].enabled) {
                link._condition = edgeConditions[linkId];
                
                // Update the link appearance
                updateLinkAppearance(link, edgeConditions[linkId]);
            }
            
            return result;
        };
        
        // Hook into the Node-RED runtime to evaluate conditions
        // This will be loaded when the flow is deployed
        RED.comms.subscribe("edge-condition-evaluate", function(topic, msg) {
            var linkId = msg.linkId;
            var condition = edgeConditions[linkId];
            var result = evaluateCondition(condition, msg.msg);
            
            // Send the result back to the runtime
            RED.comms.publish("edge-condition-result", {
                linkId: linkId,
                result: result,
                msgId: msg.msgId
            });
        });
    }

    function disposeMenu() {
        $(document).off("mousedown.red-ui-workspace-context-menu");
        if (menu) {
            menu.remove();
        }
        menu = null;
    }
    function show(options) {
        if (menu) {
            menu.remove()
        }
        let menuItems = []
        if (options.options) {
            menuItems = options.options
        } else if (options.type === 'workspace') {
            const selection = RED.view.selection()
            const noSelection = !selection || Object.keys(selection).length === 0
            const hasSelection = (selection.nodes && selection.nodes.length > 0);
            const hasMultipleSelection = hasSelection && selection.nodes.length > 1;
            const virtulLinks = (selection.links && selection.links.filter(e => !!e.link)) || [];
            const wireLinks = (selection.links && selection.links.filter(e => !e.link)) || [];
            const hasLinks = wireLinks.length > 0;
            const isSingleLink = !hasSelection && hasLinks && wireLinks.length === 1
            const isMultipleLinks = !hasSelection && hasLinks && wireLinks.length > 1
            const canDelete = hasSelection || hasLinks
            const isGroup = hasSelection && selection.nodes.length === 1 && selection.nodes[0].type === 'group'
            const canEdit = !RED.workspaces.isLocked()
            const canRemoveFromGroup = hasSelection && !!selection.nodes[0].g
            
            // ADD EDIT CONNECTION OPTION FOR LINKS
            if (hasLinks) {
                // Add the Edit Connection option at the top of the menu
                menuItems.push(
                    {
                        label: "Edit Connection",
                        onselect: function() {
                            try {
                                // Get the selected link
                                var selectedLink = wireLinks[0];
                                
                                // Get the link ID
                                var linkId = selectedLink.source.id + ':' + selectedLink.sourcePort + ':' + selectedLink.target.id;
                                
                                // Get or create the condition data
                                if (!edgeConditions[linkId]) {
                                    edgeConditions[linkId] = {
                                        property: "payload",
                                        operator: "eq",
                                        value: "",
                                        valueType: "str",
                                        enabled: false
                                    };
                                }
                                
                                console.log("Showing connection dialog for link:", linkId);
                                
                                // Show the dialog directly using the RED.editConnection function
                                setTimeout(function() {
                                    RED.editConnection(selectedLink);
                                }, 100);
                            } catch(err) {
                                console.error("Error opening connection dialog:", err);
                                RED.notify("Error opening connection dialog: " + err.toString(), "error");
                            }
                        }
                    }
                );
                // Add a separator
                menuItems.push(null);
            }
            
            let hasGroup, isAllGroups = true, hasDisabledNode, hasEnabledNode, hasLabeledNode, hasUnlabeledNode;
            if (hasSelection) {
                const nodes = selection.nodes.slice();
                while (nodes.length) {
                    const n = nodes.shift();
                    if (n.type === 'group') {
                        hasGroup = true;
                        nodes.push(...n.nodes);
                    } else {
                        isAllGroups = false;
                        if (n.d) {
                            hasDisabledNode = true;
                        } else {
                            hasEnabledNode = true;
                        }
                    }
                    if (n.l === undefined || n.l) {
                        hasLabeledNode = true;
                    } else {
                        hasUnlabeledNode = true;
                    }
                }
            }

            const scale = RED.view.scale()
            const offset = $("#red-ui-workspace-chart").offset()
            let addX = (options.x - offset.left + $("#red-ui-workspace-chart").scrollLeft()) / scale
            let addY = (options.y - offset.top + $("#red-ui-workspace-chart").scrollTop()) / scale

            if (RED.view.snapGrid) {
                const gridSize = RED.view.gridSize()
                addX = gridSize * Math.round(addX / gridSize)
                addY = gridSize * Math.round(addY / gridSize)
            }

            if (RED.settings.theme("menu.menu-item-action-list", true)) {
                menuItems.push(
                    { onselect: 'core:show-action-list', label: RED._("contextMenu.showActionList"), onpostselect: function () { } }
                )
            }
            const insertOptions = []
            menuItems.push({ label: RED._("contextMenu.insert"), options: insertOptions })
            insertOptions.push(
                {
                    label: RED._("contextMenu.node"),
                    onselect: function () {
                        RED.view.showQuickAddDialog({
                            position: [addX, addY],
                            touchTrigger: 'ontouchstart' in window,
                            splice: isSingleLink ? selection.links[0] : undefined,
                            // spliceMultiple: isMultipleLinks
                        })
                    },
                    disabled: !canEdit
                },
                (hasLinks) ? { // has least 1 wire selected
                    label: RED._("contextMenu.junction"),
                    onselect: function () {
                        RED.actions.invoke('core:split-wires-with-junctions', { x: addX, y: addY })
                    },
                    disabled: !canEdit || !hasLinks
                } : {
                    label: RED._("contextMenu.junction"),
                    onselect: function () {
                        const nn = {
                            _def: { defaults: {} },
                            type: 'junction',
                            z: RED.workspaces.active(),
                            id: RED.nodes.id(),
                            x: addX,
                            y: addY,
                            w: 0, h: 0,
                            outputs: 1,
                            inputs: 1,
                            dirty: true,
                            moved: true
                        }
                        const junction = RED.nodes.addJunction(nn);
                        const historyEvent = {
                            dirty: RED.nodes.dirty(),
                            t: 'add',
                            junctions: [junction]
                        }
                        RED.history.push(historyEvent);
                        RED.nodes.dirty(true);
                        RED.view.select({nodes: [junction] });
                        RED.view.redraw(true)
                    },
                    disabled: !canEdit
                },
                {
                    label: RED._("contextMenu.linkNodes"),
                    onselect: 'core:split-wire-with-link-nodes',
                    disabled: !canEdit || !hasLinks
                },
                null
            )
            if (RED.settings.theme("menu.menu-item-import-library", true)) {
                insertOptions.push(
                    { onselect: 'core:show-import-dialog', label: RED._('common.label.import')},
                    { onselect: 'core:show-examples-import-dialog', label: RED._('menu.label.importExample') }
                )
            }


            if (hasSelection && canEdit) {
                const nodeOptions = []
                if (!hasMultipleSelection && !isGroup) {
                    nodeOptions.push(
                        { onselect: 'core:show-node-help', label: RED._('menu.label.showNodeHelp') },
                        null
                    )
                }
                nodeOptions.push(
                    { onselect: 'core:enable-selected-nodes', label: RED._('menu.label.enableSelectedNodes'), disabled: !hasDisabledNode },
                    { onselect: 'core:disable-selected-nodes', label: RED._('menu.label.disableSelectedNodes'), disabled: !hasEnabledNode },
                    null,
                    { onselect: 'core:show-selected-node-labels', label: RED._('menu.label.showSelectedNodeLabels'), disabled: !hasUnlabeledNode },
                    { onselect: 'core:hide-selected-node-labels', label: RED._('menu.label.hideSelectedNodeLabels'), disabled: !hasLabeledNode }
                )
                menuItems.push({
                    label: RED._('sidebar.info.node'),
                    options: nodeOptions
                })
                menuItems.push({
                    label: RED._('sidebar.info.group'),
                    options: [
                        { onselect: 'core:group-selection', label: RED._("menu.label.groupSelection") },
                        { onselect: 'core:ungroup-selection', label: RED._("menu.label.ungroupSelection"), disabled: !hasGroup },
                    ]
                })
                if (hasGroup) {
                    menuItems[menuItems.length - 1].options.push(
                        { onselect: 'core:merge-selection-to-group', label: RED._("menu.label.groupMergeSelection") }
                    )

                }
                if (canRemoveFromGroup) {
                    menuItems[menuItems.length - 1].options.push(
                        { onselect: 'core:remove-selection-from-group', label: RED._("menu.label.groupRemoveSelection") }
                    )
                }
                menuItems[menuItems.length - 1].options.push(
                    null,
                    { onselect: 'core:copy-group-style', label: RED._("keyboard.copyGroupStyle"), disabled: !hasGroup },
                    { onselect: 'core:paste-group-style', label: RED._("keyboard.pasteGroupStyle"), disabled: !hasGroup}
                )
            }
            if (canEdit && hasMultipleSelection) {
                menuItems.push({
                    label: RED._('menu.label.arrange'),
                    options: [
                        { label:RED._("menu.label.alignLeft"), onselect: "core:align-selection-to-left"},
                        { label:RED._("menu.label.alignCenter"), onselect: "core:align-selection-to-center"},
                        { label:RED._("menu.label.alignRight"), onselect: "core:align-selection-to-right"},
                        null,
                        { label:RED._("menu.label.alignTop"), onselect: "core:align-selection-to-top"},
                        { label:RED._("menu.label.alignMiddle"), onselect: "core:align-selection-to-middle"},
                        { label:RED._("menu.label.alignBottom"), onselect: "core:align-selection-to-bottom"},
                        null,
                        { label:RED._("menu.label.distributeHorizontally"), onselect: "core:distribute-selection-horizontally"},
                        { label:RED._("menu.label.distributeVertically"), onselect: "core:distribute-selection-vertically"}
                    ]
                })
            }


            menuItems.push(
                null,
                { onselect: 'core:undo', label: RED._("keyboard.undoChange"), disabled: RED.history.list().length === 0 },
                { onselect: 'core:redo', label: RED._("keyboard.redoChange"), disabled: RED.history.listRedo().length === 0 },
                null,
                { onselect: 'core:cut-selection-to-internal-clipboard', label: RED._("keyboard.cutNode"), disabled: !canEdit || !hasSelection },
                { onselect: 'core:copy-selection-to-internal-clipboard', label: RED._("keyboard.copyNode"), disabled: !hasSelection },
                { onselect: 'core:paste-from-internal-clipboard', label: RED._("keyboard.pasteNode"), disabled: !canEdit || !RED.view.clipboard() },
                { onselect: 'core:delete-selection', label: RED._('keyboard.deleteSelected'), disabled: !canEdit || !canDelete },
                { onselect: 'core:delete-selection-and-reconnect', label: RED._('keyboard.deleteReconnect'), disabled: !canEdit || !canDelete },
            )
            if (RED.settings.theme("menu.menu-item-export-library", true)) {
                menuItems.push(
                    { onselect: 'core:show-export-dialog', label: RED._("menu.label.export") }
                )
            }
            menuItems.push(
                { onselect: 'core:select-all-nodes', label: RED._("keyboard.selectAll") }
            )
        }

        var direction = "right";
        var MENU_WIDTH = 500; // can not use menu width here
        if ((options.x -$(document).scrollLeft()) >
            ($(window).width() -MENU_WIDTH)) {
            direction = "left";
        }

        menu = RED.menu.init({
            direction: direction,
            onpreselect: function() {
                disposeMenu()
            },
            onpostselect: function () {
                RED.view.focus()
            },
            options: menuItems
        });

        menu.attr("id", "red-ui-workspace-context-menu");
        menu.css({
            position: "absolute"
        })
        menu.appendTo("body");

        // TODO: prevent the menu from overflowing the window.

        var top = options.y
        var left = options.x

        if (top + menu.height() - $(document).scrollTop() > $(window).height()) {
            top -= (top + menu.height()) - $(window).height() + 22;
        }
        if (left + menu.width() - $(document).scrollLeft() > $(window).width()) {
            left -= (left + menu.width()) - $(window).width() + 18;
        }
        menu.css({
            top: top + "px",
            left: left + "px"
        })
        $(".red-ui-menu.red-ui-menu-dropdown").hide();
        $(document).on("mousedown.red-ui-workspace-context-menu", function (evt) {
            if (menu && menu[0].contains(evt.target)) {
                return
            }
            disposeMenu()
        });
        menu.show();
        // set focus to first item so that pressing escape key closes the menu
        $("#red-ui-workspace-context-menu :first(ul) > a").trigger("focus")

    }
    // Allow escape key hook and other editor events to close context menu
    RED.keyboard.add("red-ui-workspace-context-menu", "escape", function () { RED.contextMenu.hide() })
    RED.events.on("editor:open", function () { RED.contextMenu.hide() });
    RED.events.on("search:open", function () { RED.contextMenu.hide() });
    RED.events.on("type-search:open", function () { RED.contextMenu.hide() });
    RED.events.on("actionList:open", function () { RED.contextMenu.hide() });
    RED.events.on("view:selection-changed", function () { RED.contextMenu.hide() });
    
    // Initialize the conditional connection system
    $(function() {
        // Load any saved edge conditions
        loadEdgeConditionsFromFlow();
        
        // Set up wiring for conditional connections
        setupConditionalWiring();
        
        // Initialize when flows are deployed
        RED.events.on("deploy", function() {
            // Make sure all links have their conditions applied
            RED.nodes.eachLink(function(link) {
                var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
                if (edgeConditions[linkId]) {
                    updateLinkAppearance(link, edgeConditions[linkId]);
                }
            });
        });
        
        // Add console log to help debug dialog issues
        console.log("Conditional connection system initialized");
    });
    
    // Add this edit connection function to RED namespace for debugging
    RED.editConnection = function(link) {
        if (!link) {
            console.warn("RED.editConnection called without a link.");
            return;
        }
        
        // Get the link ID
        var linkId = link.source.id + ':' + link.sourcePort + ':' + link.target.id;
        
        // Get or create the condition data (use deep copy to avoid modifying original during edit)
        var conditionCopy = edgeConditions[linkId] ? JSON.parse(JSON.stringify(edgeConditions[linkId])) : {};
        console.log("[RED.editConnection] Passing condition to dialog for link:", linkId, JSON.stringify(conditionCopy)); // DEBUG LOG

        // Ensure the base structure exists if creating anew - Reworked for new structure
        if (!conditionCopy.logical) {
            conditionCopy.logical = { logic: 'and', conditions: [] };
        }
        if (!conditionCopy.prompt) {
            conditionCopy.prompt = { conditions: [] };
        }
        conditionCopy.enabled = true; // Ensure enabled
        
        // Show the dialog
        showConnectionDialog(link, conditionCopy);
    };
    
    // Add a global debug function
    window.debugEditConnection = function() {
        console.log("Edit connection debug info:");
        
        // Check if RED.editor and RED.editor.editDialog are defined
        console.log("- RED.editor defined:", typeof RED.editor !== 'undefined');
        console.log("- RED.editor.editDialog defined:", typeof RED.editor.editDialog === 'function');
        
        // Check jQuery and jQuery UI
        console.log("- jQuery defined:", typeof jQuery !== 'undefined');
        console.log("- jQuery UI dialog defined:", typeof jQuery.fn.dialog === 'function');
        
        // Check for any selected links
        var selection = RED.view.selection();
        var wireLinks = (selection && selection.links && selection.links.filter(e => !e.link)) || [];
        console.log("- Selected links:", wireLinks.length);
        
        if (wireLinks.length > 0) {
            var selectedLink = wireLinks[0];
            var linkId = selectedLink.source.id + ':' + selectedLink.sourcePort + ':' + selectedLink.target.id;
            console.log("- Selected link ID:", linkId);
            
            // Try to open the dialog for this link
            console.log("- Attempting to show dialog...");
            try {
                RED.editConnection(selectedLink);
                console.log("- Dialog opened without errors");
            } catch (err) {
                console.error("- Error opening dialog:", err);
            }
        } else {
            console.log("- No links selected. Please select a link first.");
        }
        
        return "Debug complete - check console for details";
    };
    
    return {
        show: show,
        hide: disposeMenu,
        evaluateCondition: evaluateCondition,
        getCondition: function(linkId) {
            return edgeConditions[linkId];
        },
        getAllConditions: function() {
            return edgeConditions;
        },
        editConnection: function(link) {
            RED.editConnection(link);
        }
    }
})()
